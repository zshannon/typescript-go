--- old.1.0lib-noErrors.types
+++ new.1.0lib-noErrors.types
@@= skipped -32, +32 lines =@@
   * @param x A String value that contains valid JavaScript code.
   */
 declare function eval(x: string): any;
->eval : (x: string) => any
+>eval : { (x: string): any; (x: string): any; }
 >x : string
 
 /**
@@= skipped -11, +11 lines =@@
   * All other strings are considered decimal.
   */
 declare function parseInt(s: string, radix?: number): number;
->parseInt : (s: string, radix?: number) => number
+>parseInt : { (string: string, radix?: number): number; (s: string, radix?: number): number; }
 >s : string
 >radix : number
 
@@= skipped -9, +9 lines =@@
   * @param string A string that contains a floating-point number. 
   */
 declare function parseFloat(string: string): number;
->parseFloat : (string: string) => number
+>parseFloat : { (string: string): number; (string: string): number; }
 >string : string
 
 /**
@@= skipped -8, +8 lines =@@
   * @param number A numeric value.
   */
 declare function isNaN(number: number): boolean;
->isNaN : (number: number) => boolean
+>isNaN : { (number: number): boolean; (number: number): boolean; }
 >number : number
 
 /** 
@@= skipped -8, +8 lines =@@
   * @param number Any numeric value.
   */
 declare function isFinite(number: number): boolean;
->isFinite : (number: number) => boolean
+>isFinite : { (number: number): boolean; (number: number): boolean; }
 >number : number
 
 /**
@@= skipped -8, +8 lines =@@
   * @param encodedURI A value representing an encoded URI.
   */
 declare function decodeURI(encodedURI: string): string;
->decodeURI : (encodedURI: string) => string
+>decodeURI : { (encodedURI: string): string; (encodedURI: string): string; }
 >encodedURI : string
 
 /**
@@= skipped -8, +8 lines =@@
   * @param encodedURIComponent A value representing an encoded URI component.
   */
 declare function decodeURIComponent(encodedURIComponent: string): string;
->decodeURIComponent : (encodedURIComponent: string) => string
+>decodeURIComponent : { (encodedURIComponent: string): string; (encodedURIComponent: string): string; }
 >encodedURIComponent : string
 
 /** 
@@= skipped -8, +8 lines =@@
   * @param uri A value representing an encoded URI.
   */
 declare function encodeURI(uri: string): string;
->encodeURI : (uri: string) => string
+>encodeURI : { (uri: string): string; (uri: string): string; }
 >uri : string
 
 /**
@@= skipped -8, +8 lines =@@
   * @param uriComponent A value representing an encoded URI component.
   */
 declare function encodeURIComponent(uriComponent: string | number | boolean): string;
->encodeURIComponent : (uriComponent: string | number | boolean) => string
+>encodeURIComponent : { (uriComponent: string | number | boolean): string; (uriComponent: string | number | boolean): string; }
 >uriComponent : string | number | boolean
 
 interface PropertyDescriptor {
@@= skipped -17, +17 lines =@@
 >writable : boolean
 
     get?(): any;
->get : () => any
+>get : { (): any; (): any; }
 
     set?(v: any): void;
->set : (v: any) => void
+>set : { (v: any): void; (v: any): void; }
 >v : any
 }
 
@@= skipped -19, +19 lines =@@
 
     /** Returns a string representation of an object. */
     toString(): string;
->toString : () => string
+>toString : { (): string; (): string; }
 
     /** Returns a date converted to a string using the current locale. */
     toLocaleString(): string;
->toLocaleString : () => string
+>toLocaleString : { (): string; (): string; }
 
     /** Returns the primitive value of the specified object. */
     valueOf(): Object;
->valueOf : () => Object
+>valueOf : { (): Object; (): Object; }
 
     /**
       * Determines whether an object has a property with the specified name. 
       * @param v A property name.
       */
     hasOwnProperty(v: string): boolean;
->hasOwnProperty : (v: string) => boolean
+>hasOwnProperty : { (v: PropertyKey): boolean; (v: string): boolean; }
 >v : string
 
     /**
@@= skipped -23, +23 lines =@@
       * @param v Another object whose prototype chain is to be checked.
       */
     isPrototypeOf(v: Object): boolean;
->isPrototypeOf : (v: Object) => boolean
+>isPrototypeOf : { (v: Object): boolean; (v: Object): boolean; }
 >v : Object
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param v A property name.
       */
     propertyIsEnumerable(v: string): boolean;
->propertyIsEnumerable : (v: string) => boolean
+>propertyIsEnumerable : { (v: PropertyKey): boolean; (v: string): boolean; }
 >v : string
 }
 
@@= skipped -8, +8 lines =@@
   * Provides functionality common to all JavaScript objects.
   */
 declare var Object: {
->Object : { (): any; (value: any): any; new (value?: any): Object; prototype: Object; getPrototypeOf(o: any): any; getOwnPropertyDescriptor(o: any, p: string): PropertyDescriptor; getOwnPropertyNames(o: any): string[]; create(o: any, properties?: PropertyDescriptorMap): any; defineProperty(o: any, p: string, attributes: PropertyDescriptor): any; defineProperties(o: any, properties: PropertyDescriptorMap): any; seal(o: any): any; freeze(o: any): any; preventExtensions(o: any): any; isSealed(o: any): boolean; isFrozen(o: any): boolean; isExtensible(o: any): boolean; keys(o: any): string[]; }
+>Object : ObjectConstructor
 
     new (value?: any): Object;
 >value : any
@@= skipped -140, +140 lines =@@
       * @param argArray A set of arguments to be passed to the function.
       */
     apply(thisArg: any, argArray?: any): any;
->apply : (thisArg: any, argArray?: any) => any
+>apply : { (this: Function, thisArg: any, argArray?: any): any; (thisArg: any, argArray?: any): any; }
 >thisArg : any
 >argArray : any
 
@@= skipped -10, +10 lines =@@
       * @param argArray A list of arguments to be passed to the method.
       */
     call(thisArg: any, ...argArray: any[]): any;
->call : (thisArg: any, ...argArray: any[]) => any
+>call : { (this: Function, thisArg: any, ...argArray: any[]): any; (thisArg: any, ...argArray: any[]): any; }
 >thisArg : any
 >argArray : any[]
 
@@= skipped -11, +11 lines =@@
       * @param argArray A list of arguments to be passed to the new function.
       */
     bind(thisArg: any, ...argArray: any[]): any;
->bind : (thisArg: any, ...argArray: any[]) => any
+>bind : { (this: Function, thisArg: any, ...argArray: any[]): any; (thisArg: any, ...argArray: any[]): any; }
 >thisArg : any
 >argArray : any[]
 
@@= skipped -19, +19 lines =@@
 }
 
 declare var Function: {
->Function : { (...args: string[]): Function; new (...args: string[]): Function; prototype: Function; }
+>Function : FunctionConstructor
 
     /** 
       * Creates a new function.
@@= skipped -30, +30 lines =@@
 interface String {
     /** Returns a string representation of a string. */
     toString(): string;
->toString : () => string
+>toString : { (): string; (): string; }
 
     /**
       * Returns the character at the specified index.
       * @param pos The zero-based index of the desired character.
       */
     charAt(pos: number): string;
->charAt : (pos: number) => string
+>charAt : { (pos: number): string; (pos: number): string; }
 >pos : number
 
     /** 
@@= skipped -15, +15 lines =@@
       * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.
       */
     charCodeAt(index: number): number;
->charCodeAt : (index: number) => number
+>charCodeAt : { (index: number): number; (index: number): number; }
 >index : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param strings The strings to append to the end of the string.  
       */
     concat(...strings: string[]): string;
->concat : (...strings: string[]) => string
+>concat : { (...strings: string[]): string; (...strings: string[]): string; }
 >strings : string[]
 
     /**
@@= skipped -9, +9 lines =@@
       * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.
       */
     indexOf(searchString: string, position?: number): number;
->indexOf : (searchString: string, position?: number) => number
+>indexOf : { (searchString: string, position?: number): number; (searchString: string, position?: number): number; }
 >searchString : string
 >position : number
 
@@= skipped -10, +10 lines =@@
       * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.
       */
     lastIndexOf(searchString: string, position?: number): number;
->lastIndexOf : (searchString: string, position?: number) => number
+>lastIndexOf : { (searchString: string, position?: number): number; (searchString: string, position?: number): number; }
 >searchString : string
 >position : number
 
@@= skipped -9, +9 lines =@@
       * @param that String to compare to target string
       */
     localeCompare(that: string): number;
->localeCompare : (that: string) => number
+>localeCompare : { (that: string): number; (that: string, locales?: string | string[], options?: CollatorOptions): number; (that: string): number; }
 >that : string
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param regexp A variable name or string literal containing the regular expression pattern and flags.
       */
     match(regexp: string): string[];
->match : { (regexp: string): string[]; (regexp: RegExp): string[]; }
+>match : { (regexp: string | RegExp): RegExpMatchArray; (regexp: string): string[]; (regexp: RegExp): string[]; }
 >regexp : string
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param regexp A regular expression object that contains the regular expression pattern and applicable flags. 
       */
     match(regexp: RegExp): string[];
->match : { (regexp: string): string[]; (regexp: RegExp): string[]; }
+>match : { (regexp: string | RegExp): RegExpMatchArray; (regexp: string): string[]; (regexp: RegExp): string[]; }
 >regexp : RegExp
 
     /**
@@= skipped -9, +9 lines =@@
       * @param replaceValue A String object or string literal containing the text to replace for every successful match of rgExp in stringObj.
       */
     replace(searchValue: string, replaceValue: string): string;
->replace : { (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
+>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
 >searchValue : string
 >replaceValue : string
 
@@= skipped -10, +10 lines =@@
       * @param replaceValue A function that returns the replacement text.
       */
     replace(searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string;
->replace : { (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
+>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
 >searchValue : string
 >replaceValue : (substring: string, ...args: any[]) => string
 >substring : string
@@= skipped -12, +12 lines =@@
       * @param replaceValue A String object or string literal containing the text to replace for every successful match of rgExp in stringObj.
       */
     replace(searchValue: RegExp, replaceValue: string): string;
->replace : { (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
+>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
 >searchValue : RegExp
 >replaceValue : string
 
@@= skipped -10, +10 lines =@@
       * @param replaceValue A function that returns the replacement text.
       */
     replace(searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string;
->replace : { (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
+>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: string, replaceValue: string): string; (searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string; (searchValue: RegExp, replaceValue: string): string; (searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string; }
 >searchValue : RegExp
 >replaceValue : (substring: string, ...args: any[]) => string
 >substring : string
@@= skipped -11, +11 lines =@@
       * @param regexp The regular expression pattern and applicable flags. 
       */
     search(regexp: string): number;
->search : { (regexp: string): number; (regexp: RegExp): number; }
+>search : { (regexp: string | RegExp): number; (regexp: string): number; (regexp: RegExp): number; }
 >regexp : string
 
     /**
@@= skipped -8, +8 lines =@@
       * @param regexp The regular expression pattern and applicable flags. 
       */
     search(regexp: RegExp): number;
->search : { (regexp: string): number; (regexp: RegExp): number; }
+>search : { (regexp: string | RegExp): number; (regexp: string): number; (regexp: RegExp): number; }
 >regexp : RegExp
 
     /**
@@= skipped -10, +10 lines =@@
       * If this value is not specified, the substring continues to the end of stringObj.
       */
     slice(start?: number, end?: number): string;
->slice : (start?: number, end?: number) => string
+>slice : { (start?: number, end?: number): string; (start?: number, end?: number): string; }
 >start : number
 >end : number
 
@@= skipped -10, +10 lines =@@
       * @param limit A value used to limit the number of elements returned in the array.
       */
     split(separator: string, limit?: number): string[];
->split : { (separator: string, limit?: number): string[]; (separator: RegExp, limit?: number): string[]; }
+>split : { (separator: string | RegExp, limit?: number): string[]; (separator: string, limit?: number): string[]; (separator: RegExp, limit?: number): string[]; }
 >separator : string
 >limit : number
 
@@= skipped -10, +10 lines =@@
       * @param limit A value used to limit the number of elements returned in the array.
       */
     split(separator: RegExp, limit?: number): string[];
->split : { (separator: string, limit?: number): string[]; (separator: RegExp, limit?: number): string[]; }
+>split : { (separator: string | RegExp, limit?: number): string[]; (separator: string, limit?: number): string[]; (separator: RegExp, limit?: number): string[]; }
 >separator : RegExp
 >limit : number
 
@@= skipped -11, +11 lines =@@
       * If end is omitted, the characters from start through the end of the original string are returned.
       */
     substring(start: number, end?: number): string;
->substring : (start: number, end?: number) => string
+>substring : { (start: number, end?: number): string; (start: number, end?: number): string; }
 >start : number
 >end : number
 
     /** Converts all the alphabetic characters in a string to lowercase. */
     toLowerCase(): string;
->toLowerCase : () => string
+>toLowerCase : { (): string; (): string; }
 
     /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */
     toLocaleLowerCase(): string;
->toLocaleLowerCase : () => string
+>toLocaleLowerCase : { (locales?: string | string[]): string; (): string; }
 
     /** Converts all the alphabetic characters in a string to uppercase. */
     toUpperCase(): string;
->toUpperCase : () => string
+>toUpperCase : { (): string; (): string; }
 
     /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */
     toLocaleUpperCase(): string;
->toLocaleUpperCase : () => string
+>toLocaleUpperCase : { (locales?: string | string[]): string; (): string; }
 
     /** Removes the leading and trailing white space and line terminator characters from a string. */
     trim(): string;
->trim : () => string
+>trim : { (): string; (): string; }
 
     /** Returns the length of a String object. */
     length: number;
@@= skipped -35, +35 lines =@@
       * @param length The number of characters to include in the returned substring.
       */
     substr(from: number, length?: number): string;
->substr : (from: number, length?: number) => string
+>substr : { (from: number, length?: number): string; (from: number, length?: number): string; }
 >from : number
 >length : number
 
@@= skipped -12, +12 lines =@@
   * Allows manipulation and formatting of text strings and determination and location of substrings within strings. 
   */
 declare var String: {
->String : { (value?: any): string; new (value?: any): String; prototype: String; fromCharCode(...codes: number[]): string; }
+>String : StringConstructor
 
     new (value?: any): String;
 >value : any
@@= skipped -19, +19 lines =@@
 interface Boolean {
 }
 declare var Boolean: {
->Boolean : { (value?: any): boolean; new (value?: any): Boolean; prototype: Boolean; }
+>Boolean : BooleanConstructor
 
     new (value?: any): Boolean;
 >value : any
@@= skipped -18, +18 lines =@@
       * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.
       */
     toString(radix?: number): string;
->toString : (radix?: number) => string
+>toString : { (radix?: number): string; (radix?: number): string; }
 >radix : number
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.
       */
     toFixed(fractionDigits?: number): string;
->toFixed : (fractionDigits?: number) => string
+>toFixed : { (fractionDigits?: number): string; (fractionDigits?: number): string; }
 >fractionDigits : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.
       */
     toExponential(fractionDigits?: number): string;
->toExponential : (fractionDigits?: number) => string
+>toExponential : { (fractionDigits?: number): string; (fractionDigits?: number): string; }
 >fractionDigits : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.
       */
     toPrecision(precision?: number): string;
->toPrecision : (precision?: number) => string
+>toPrecision : { (precision?: number): string; (precision?: number): string; }
 >precision : number
 }
 
 /** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */
 declare var Number: {
->Number : { (value?: any): number; new (value?: any): Number; prototype: Number; MAX_VALUE: number; MIN_VALUE: number; NaN: number; NEGATIVE_INFINITY: number; POSITIVE_INFINITY: number; }
+>Number : NumberConstructor
 
     new (value?: any): Number;
 >value : any
@@= skipped -86, +86 lines =@@
       * @param x A numeric expression for which the absolute value is needed.
       */
     abs(x: number): number;
->abs : (x: number) => number
+>abs : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression.
       */
     acos(x: number): number;
->acos : (x: number) => number
+>acos : { (x: number): number; (x: number): number; }
 >x : number
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression.
       */
     asin(x: number): number;
->asin : (x: number) => number
+>asin : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression for which the arctangent is needed.
       */
     atan(x: number): number;
->atan : (x: number) => number
+>atan : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -9, +9 lines =@@
       * @param x A numeric expression representing the cartesian x-coordinate.
       */
     atan2(y: number, x: number): number;
->atan2 : (y: number, x: number) => number
+>atan2 : { (y: number, x: number): number; (y: number, x: number): number; }
 >y : number
 >x : number
 
@@= skipped -9, +9 lines =@@
       * @param x A numeric expression.
       */
     ceil(x: number): number;
->ceil : (x: number) => number
+>ceil : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression that contains an angle measured in radians.
       */
     cos(x: number): number;
->cos : (x: number) => number
+>cos : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression representing the power of e.
       */
     exp(x: number): number;
->exp : (x: number) => number
+>exp : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression.
       */
     floor(x: number): number;
->floor : (x: number) => number
+>floor : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression.
       */
     log(x: number): number;
->log : (x: number) => number
+>log : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param values Numeric expressions to be evaluated.
       */
     max(...values: number[]): number;
->max : (...values: number[]) => number
+>max : { (...values: number[]): number; (...values: number[]): number; }
 >values : number[]
 
     /**
@@= skipped -8, +8 lines =@@
       * @param values Numeric expressions to be evaluated.
       */
     min(...values: number[]): number;
->min : (...values: number[]) => number
+>min : { (...values: number[]): number; (...values: number[]): number; }
 >values : number[]
 
     /**
@@= skipped -9, +9 lines =@@
       * @param y The exponent value of the expression.
       */
     pow(x: number, y: number): number;
->pow : (x: number, y: number) => number
+>pow : { (x: number, y: number): number; (x: number, y: number): number; }
 >x : number
 >y : number
 
     /** Returns a pseudorandom number between 0 and 1. */
     random(): number;
->random : () => number
+>random : { (): number; (): number; }
 
     /** 
       * Returns a supplied numeric expression rounded to the nearest number.
       * @param x The value to be rounded to the nearest number.
       */
     round(x: number): number;
->round : (x: number) => number
+>round : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -21, +21 lines =@@
       * @param x A numeric expression that contains an angle measured in radians.
       */
     sin(x: number): number;
->sin : (x: number) => number
+>sin : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression.
       */
     sqrt(x: number): number;
->sqrt : (x: number) => number
+>sqrt : { (x: number): number; (x: number): number; }
 >x : number
 
     /**
@@= skipped -8, +8 lines =@@
       * @param x A numeric expression that contains an angle measured in radians.
       */
     tan(x: number): number;
->tan : (x: number) => number
+>tan : { (x: number): number; (x: number): number; }
 >x : number
 }
 /** An intrinsic object that provides basic mathematics functionality and constants. */
@@= skipped -11, +11 lines =@@
 interface Date {
     /** Returns a string representation of a date. The format of the string depends on the locale. */
     toString(): string;
->toString : () => string
+>toString : { (): string; (): string; }
 
     /** Returns a date as a string value. */
     toDateString(): string;
->toDateString : () => string
+>toDateString : { (): string; (): string; }
 
     /** Returns a time as a string value. */
     toTimeString(): string;
->toTimeString : () => string
+>toTimeString : { (): string; (): string; }
 
     /** Returns a value as a string value appropriate to the host environment's current locale. */
     toLocaleString(): string;
->toLocaleString : () => string
+>toLocaleString : { (): string; (locales?: string | string[], options?: DateTimeFormatOptions): string; (): string; }
 
     /** Returns a date as a string value appropriate to the host environment's current locale. */
     toLocaleDateString(): string;
->toLocaleDateString : () => string
+>toLocaleDateString : { (): string; (locales?: string | string[], options?: DateTimeFormatOptions): string; (): string; }
 
     /** Returns a time as a string value appropriate to the host environment's current locale. */
     toLocaleTimeString(): string;
->toLocaleTimeString : () => string
+>toLocaleTimeString : { (): string; (locales?: string | string[], options?: DateTimeFormatOptions): string; (): string; }
 
     /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */
     valueOf(): number;
->valueOf : () => number
+>valueOf : { (): number; (): number; }
 
     /** Gets the time value in milliseconds. */
     getTime(): number;
->getTime : () => number
+>getTime : { (): number; (): number; }
 
     /** Gets the year, using local time. */
     getFullYear(): number;
->getFullYear : () => number
+>getFullYear : { (): number; (): number; }
 
     /** Gets the year using Universal Coordinated Time (UTC). */
     getUTCFullYear(): number;
->getUTCFullYear : () => number
+>getUTCFullYear : { (): number; (): number; }
 
     /** Gets the month, using local time. */
     getMonth(): number;
->getMonth : () => number
+>getMonth : { (): number; (): number; }
 
     /** Gets the month of a Date object using Universal Coordinated Time (UTC). */
     getUTCMonth(): number;
->getUTCMonth : () => number
+>getUTCMonth : { (): number; (): number; }
 
     /** Gets the day-of-the-month, using local time. */
     getDate(): number;
->getDate : () => number
+>getDate : { (): number; (): number; }
 
     /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */
     getUTCDate(): number;
->getUTCDate : () => number
+>getUTCDate : { (): number; (): number; }
 
     /** Gets the day of the week, using local time. */
     getDay(): number;
->getDay : () => number
+>getDay : { (): number; (): number; }
 
     /** Gets the day of the week using Universal Coordinated Time (UTC). */
     getUTCDay(): number;
->getUTCDay : () => number
+>getUTCDay : { (): number; (): number; }
 
     /** Gets the hours in a date, using local time. */
     getHours(): number;
->getHours : () => number
+>getHours : { (): number; (): number; }
 
     /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */
     getUTCHours(): number;
->getUTCHours : () => number
+>getUTCHours : { (): number; (): number; }
 
     /** Gets the minutes of a Date object, using local time. */
     getMinutes(): number;
->getMinutes : () => number
+>getMinutes : { (): number; (): number; }
 
     /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */
     getUTCMinutes(): number;
->getUTCMinutes : () => number
+>getUTCMinutes : { (): number; (): number; }
 
     /** Gets the seconds of a Date object, using local time. */
     getSeconds(): number;
->getSeconds : () => number
+>getSeconds : { (): number; (): number; }
 
     /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */
     getUTCSeconds(): number;
->getUTCSeconds : () => number
+>getUTCSeconds : { (): number; (): number; }
 
     /** Gets the milliseconds of a Date, using local time. */
     getMilliseconds(): number;
->getMilliseconds : () => number
+>getMilliseconds : { (): number; (): number; }
 
     /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */
     getUTCMilliseconds(): number;
->getUTCMilliseconds : () => number
+>getUTCMilliseconds : { (): number; (): number; }
 
     /** Gets the difference in minutes between Universal Coordinated Time (UTC) and the time on the local computer. */
     getTimezoneOffset(): number;
->getTimezoneOffset : () => number
+>getTimezoneOffset : { (): number; (): number; }
 
     /** 
       * Sets the date and time value in the Date object.
       * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT. 
       */
     setTime(time: number): number;
->setTime : (time: number) => number
+>setTime : { (time: number): number; (time: number): number; }
 >time : number
 
     /**
@@= skipped -111, +111 lines =@@
       * @param ms A numeric value equal to the millisecond value.
       */
     setMilliseconds(ms: number): number;
->setMilliseconds : (ms: number) => number
+>setMilliseconds : { (ms: number): number; (ms: number): number; }
 >ms : number
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param ms A numeric value equal to the millisecond value. 
       */
     setUTCMilliseconds(ms: number): number;
->setUTCMilliseconds : (ms: number) => number
+>setUTCMilliseconds : { (ms: number): number; (ms: number): number; }
 >ms : number
 
     /**
@@= skipped -9, +9 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setSeconds(sec: number, ms?: number): number;
->setSeconds : (sec: number, ms?: number) => number
+>setSeconds : { (sec: number, ms?: number): number; (sec: number, ms?: number): number; }
 >sec : number
 >ms : number
 
@@= skipped -10, +10 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setUTCSeconds(sec: number, ms?: number): number;
->setUTCSeconds : (sec: number, ms?: number) => number
+>setUTCSeconds : { (sec: number, ms?: number): number; (sec: number, ms?: number): number; }
 >sec : number
 >ms : number
 
@@= skipped -11, +11 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setMinutes(min: number, sec?: number, ms?: number): number;
->setMinutes : (min: number, sec?: number, ms?: number) => number
+>setMinutes : { (min: number, sec?: number, ms?: number): number; (min: number, sec?: number, ms?: number): number; }
 >min : number
 >sec : number
 >ms : number
@@= skipped -12, +12 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setUTCMinutes(min: number, sec?: number, ms?: number): number;
->setUTCMinutes : (min: number, sec?: number, ms?: number) => number
+>setUTCMinutes : { (min: number, sec?: number, ms?: number): number; (min: number, sec?: number, ms?: number): number; }
 >min : number
 >sec : number
 >ms : number
@@= skipped -13, +13 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setHours(hours: number, min?: number, sec?: number, ms?: number): number;
->setHours : (hours: number, min?: number, sec?: number, ms?: number) => number
+>setHours : { (hours: number, min?: number, sec?: number, ms?: number): number; (hours: number, min?: number, sec?: number, ms?: number): number; }
 >hours : number
 >min : number
 >sec : number
@@= skipped -14, +14 lines =@@
       * @param ms A numeric value equal to the milliseconds value.
       */
     setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;
->setUTCHours : (hours: number, min?: number, sec?: number, ms?: number) => number
+>setUTCHours : { (hours: number, min?: number, sec?: number, ms?: number): number; (hours: number, min?: number, sec?: number, ms?: number): number; }
 >hours : number
 >min : number
 >sec : number
@@= skipped -11, +11 lines =@@
       * @param date A numeric value equal to the day of the month.
       */
     setDate(date: number): number;
->setDate : (date: number) => number
+>setDate : { (date: number): number; (date: number): number; }
 >date : number
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param date A numeric value equal to the day of the month. 
       */
     setUTCDate(date: number): number;
->setUTCDate : (date: number) => number
+>setUTCDate : { (date: number): number; (date: number): number; }
 >date : number
 
     /** 
@@= skipped -9, +9 lines =@@
       * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.
       */
     setMonth(month: number, date?: number): number;
->setMonth : (month: number, date?: number) => number
+>setMonth : { (month: number, date?: number): number; (month: number, date?: number): number; }
 >month : number
 >date : number
 
@@= skipped -10, +10 lines =@@
       * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.
       */
     setUTCMonth(month: number, date?: number): number;
->setUTCMonth : (month: number, date?: number) => number
+>setUTCMonth : { (month: number, date?: number): number; (month: number, date?: number): number; }
 >month : number
 >date : number
 
@@= skipped -11, +11 lines =@@
       * @param date A numeric value equal for the day of the month.
       */
     setFullYear(year: number, month?: number, date?: number): number;
->setFullYear : (year: number, month?: number, date?: number) => number
+>setFullYear : { (year: number, month?: number, date?: number): number; (year: number, month?: number, date?: number): number; }
 >year : number
 >month : number
 >date : number
@@= skipped -12, +12 lines =@@
       * @param date A numeric value equal to the day of the month.
       */
     setUTCFullYear(year: number, month?: number, date?: number): number;
->setUTCFullYear : (year: number, month?: number, date?: number) => number
+>setUTCFullYear : { (year: number, month?: number, date?: number): number; (year: number, month?: number, date?: number): number; }
 >year : number
 >month : number
 >date : number
 
     /** Returns a date converted to a string using Universal Coordinated Time (UTC). */
     toUTCString(): string;
->toUTCString : () => string
+>toUTCString : { (): string; (): string; }
 
     /** Returns a date as a string value in ISO format. */
     toISOString(): string;
->toISOString : () => string
+>toISOString : { (): string; (): string; }
 
     /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */
     toJSON(key?: any): string;
->toJSON : (key?: any) => string
+>toJSON : { (key?: any): string; (key?: any): string; }
 >key : any
 }
 
 declare var Date: {
->Date : { (): string; new (): Date; new (value: number): Date; new (value: string): Date; new (year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date; prototype: Date; parse(s: string): number; UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number; now(): number; }
+>Date : DateConstructor
 
     new (): Date;
     new (value: number): Date;
@@= skipped -215, +215 lines =@@
       * @param string The String object or string literal on which to perform the search.
       */
     exec(string: string): RegExpExecArray;
->exec : (string: string) => RegExpExecArray
+>exec : { (string: string): RegExpExecArray; (string: string): RegExpExecArray; }
 >string : string
 
     /** 
@@= skipped -8, +8 lines =@@
       * @param string String on which to perform the search.
       */
     test(string: string): boolean;
->test : (string: string) => boolean
+>test : { (string: string): boolean; (string: string): boolean; }
 >string : string
 
     /** Returns a copy of the text of the regular expression pattern. Read-only. The rgExp argument is a Regular expression object. It can be a variable name or a literal. */
@@= skipped -24, +24 lines =@@
 
     // Non-standard extensions
     compile(): RegExp;
->compile : () => RegExp
+>compile : { (pattern: string, flags?: string): this; (): RegExp; }
 }
 declare var RegExp: {
->RegExp : { (pattern: string, flags?: string): RegExp; new (pattern: string, flags?: string): RegExp; $1: string; $2: string; $3: string; $4: string; $5: string; $6: string; $7: string; $8: string; $9: string; lastMatch: string; }
+>RegExp : RegExpConstructor
 
     new (pattern: string, flags?: string): RegExp;
 >pattern : string
@@= skipped -53, +53 lines =@@
 >message : string
 }
 declare var Error: {
->Error : { (message?: string): Error; new (message?: string): Error; prototype: Error; }
+>Error : ErrorConstructor
 
     new (message?: string): Error;
 >message : string
@@= skipped -15, +15 lines =@@
 interface EvalError extends Error {
 }
 declare var EvalError: {
->EvalError : { (message?: string): EvalError; new (message?: string): EvalError; prototype: EvalError; }
+>EvalError : EvalErrorConstructor
 
     new (message?: string): EvalError;
 >message : string
@@= skipped -15, +15 lines =@@
 interface RangeError extends Error {
 }
 declare var RangeError: {
->RangeError : { (message?: string): RangeError; new (message?: string): RangeError; prototype: RangeError; }
+>RangeError : RangeErrorConstructor
 
     new (message?: string): RangeError;
 >message : string
@@= skipped -15, +15 lines =@@
 interface ReferenceError extends Error {
 }
 declare var ReferenceError: {
->ReferenceError : { (message?: string): ReferenceError; new (message?: string): ReferenceError; prototype: ReferenceError; }
+>ReferenceError : ReferenceErrorConstructor
 
     new (message?: string): ReferenceError;
 >message : string
@@= skipped -15, +15 lines =@@
 interface SyntaxError extends Error {
 }
 declare var SyntaxError: {
->SyntaxError : { (message?: string): SyntaxError; new (message?: string): SyntaxError; prototype: SyntaxError; }
+>SyntaxError : SyntaxErrorConstructor
 
     new (message?: string): SyntaxError;
 >message : string
@@= skipped -15, +15 lines =@@
 interface TypeError extends Error {
 }
 declare var TypeError: {
->TypeError : { (message?: string): TypeError; new (message?: string): TypeError; prototype: TypeError; }
+>TypeError : TypeErrorConstructor
 
     new (message?: string): TypeError;
 >message : string
@@= skipped -15, +15 lines =@@
 interface URIError extends Error {
 }
 declare var URIError: {
->URIError : { (message?: string): URIError; new (message?: string): URIError; prototype: URIError; }
+>URIError : URIErrorConstructor
 
     new (message?: string): URIError;
 >message : string
@@= skipped -20, +20 lines =@@
       * If a member contains nested objects, the nested objects are transformed before the parent object is. 
       */
     parse(text: string, reviver?: (key: any, value: any) => any): any;
->parse : (text: string, reviver?: (key: any, value: any) => any) => any
+>parse : { (text: string, reviver?: (this: any, key: string, value: any) => any): any; (text: string, reviver?: (key: any, value: any) => any): any; }
 >text : string
 >reviver : (key: any, value: any) => any
 >key : any
@@= skipped -11, +11 lines =@@
       * @param value A JavaScript value, usually an object or array, to be converted.
       */
     stringify(value: any): string;
->stringify : { (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
 >value : any
 
     /**
@@= skipped -9, +9 lines =@@
       * @param replacer A function that transforms the results.
       */
     stringify(value: any, replacer: (key: string, value: any) => any): string;
->stringify : { (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
 >value : any
 >replacer : (key: string, value: any) => any
 >key : string
@@= skipped -12, +12 lines =@@
       * @param replacer Array that transforms the results.
       */
     stringify(value: any, replacer: any[]): string;
->stringify : { (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
 >value : any
 >replacer : any[]
 
@@= skipped -11, +11 lines =@@
       * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
       */
     stringify(value: any, replacer: (key: string, value: any) => any, space: any): string;
->stringify : { (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
 >value : any
 >replacer : (key: string, value: any) => any
 >key : string
@@= skipped -14, +14 lines =@@
       * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
       */
     stringify(value: any, replacer: any[], space: any): string;
->stringify : { (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; (value: any): string; (value: any, replacer: (key: string, value: any) => any): string; (value: any, replacer: any[]): string; (value: any, replacer: (key: string, value: any) => any, space: any): string; (value: any, replacer: any[], space: any): string; }
 >value : any
 >replacer : any[]
 >space : any
@@= skipped -21, +21 lines =@@
       * Returns a string representation of an array.
       */
     toString(): string;
->toString : () => string
+>toString : { (): string; (): string; }
 
     toLocaleString(): string;
->toLocaleString : () => string
+>toLocaleString : { (): string; (): string; }
 
     /**
       * Combines two or more arrays.
       * @param items Additional items to add to the end of array1.
       */
     concat<U extends T[]>(...items: U[]): T[];
->concat : { <U extends T[]>(...items: U[]): T[]; (...items: T[]): T[]; }
+>concat : { (...items: ConcatArray<T>[]): T[]; (...items: (T | ConcatArray<T>)[]): T[]; <U extends T[]>(...items: U[]): T[]; (...items: T[]): T[]; }
 >items : U[]
 
     /**
@@= skipped -18, +18 lines =@@
       * @param items Additional items to add to the end of array1.
       */
     concat(...items: T[]): T[];
->concat : { <U extends T[]>(...items: U[]): T[]; (...items: T[]): T[]; }
+>concat : { (...items: ConcatArray<T>[]): T[]; (...items: (T | ConcatArray<T>)[]): T[]; <U extends T[]>(...items: U[]): T[]; (...items: T[]): T[]; }
 >items : T[]
 
     /**
@@= skipped -8, +8 lines =@@
       * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
       */
     join(separator?: string): string;
->join : (separator?: string) => string
+>join : { (separator?: string): string; (separator?: string): string; }
 >separator : string
 
     /**
       * Removes the last element from an array and returns it.
       */
     pop(): T;
->pop : () => T
+>pop : { (): T; (): T; }
 
     /**
       * Appends new elements to an array, and returns the new length of the array.
       * @param items New elements of the Array.
       */
     push(...items: T[]): number;
->push : (...items: T[]) => number
+>push : { (...items: T[]): number; (...items: T[]): number; }
 >items : T[]
 
     /**
       * Reverses the elements in an Array. 
       */
     reverse(): T[];
->reverse : () => T[]
+>reverse : { (): T[]; (): T[]; }
 
     /**
       * Removes the first element from an array and returns it.
       */
     shift(): T;
->shift : () => T
+>shift : { (): T; (): T; }
 
     /** 
       * Returns a section of an array.
@@= skipped -35, +35 lines =@@
       * @param end The end of the specified portion of the array.
       */
     slice(start?: number, end?: number): T[];
->slice : (start?: number, end?: number) => T[]
+>slice : { (start?: number, end?: number): T[]; (start?: number, end?: number): T[]; }
 >start : number
 >end : number
 
@@= skipped -9, +9 lines =@@
       * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.
       */
     sort(compareFn?: (a: T, b: T) => number): T[];
->sort : (compareFn?: (a: T, b: T) => number) => T[]
+>sort : { (compareFn?: (a: T, b: T) => number): this; (compareFn?: (a: T, b: T) => number): T[]; }
 >compareFn : (a: T, b: T) => number
 >a : T
 >b : T
@@= skipped -10, +10 lines =@@
       * @param start The zero-based location in the array from which to start removing elements.
       */
     splice(start: number): T[];
->splice : { (start: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
+>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; (start: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
 >start : number
 
     /**
@@= skipped -10, +10 lines =@@
       * @param items Elements to insert into the array in place of the deleted elements.
       */
     splice(start: number, deleteCount: number, ...items: T[]): T[];
->splice : { (start: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
+>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; (start: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
 >start : number
 >deleteCount : number
 >items : T[]
@@= skipped -10, +10 lines =@@
       * @param items  Elements to insert at the start of the Array.
       */
     unshift(...items: T[]): number;
->unshift : (...items: T[]) => number
+>unshift : { (...items: T[]): number; (...items: T[]): number; }
 >items : T[]
 
     /**
@@= skipped -9, +9 lines =@@
       * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
       */
     indexOf(searchElement: T, fromIndex?: number): number;
->indexOf : (searchElement: T, fromIndex?: number) => number
+>indexOf : { (searchElement: T, fromIndex?: number): number; (searchElement: T, fromIndex?: number): number; }
 >searchElement : T
 >fromIndex : number
 
@@= skipped -10, +10 lines =@@
       * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
       */
     lastIndexOf(searchElement: T, fromIndex?: number): number;
->lastIndexOf : (searchElement: T, fromIndex?: number) => number
+>lastIndexOf : { (searchElement: T, fromIndex?: number): number; (searchElement: T, fromIndex?: number): number; }
 >searchElement : T
 >fromIndex : number
 
@@= skipped -10, +10 lines =@@
       * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
       */
     every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
->every : (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean
+>every : { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean; }
 >callbackfn : (value: T, index: number, array: T[]) => boolean
 >value : T
 >index : number
@@= skipped -13, +13 lines =@@
       * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
       */
     some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
->some : (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean
+>some : { (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean; }
 >callbackfn : (value: T, index: number, array: T[]) => boolean
 >value : T
 >index : number
@@= skipped -13, +13 lines =@@
       * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
       */
     forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
->forEach : (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) => void
+>forEach : { (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void; (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void; }
 >callbackfn : (value: T, index: number, array: T[]) => void
 >value : T
 >index : number
@@= skipped -13, +13 lines =@@
       * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
       */
     map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];
->map : <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]
+>map : { <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[]; <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[]; }
 >callbackfn : (value: T, index: number, array: T[]) => U
 >value : T
 >index : number
@@= skipped -13, +13 lines =@@
       * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
       */
     filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];
->filter : (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => T[]
+>filter : { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[]; }
 >callbackfn : (value: T, index: number, array: T[]) => boolean
 >value : T
 >index : number
@@= skipped -13, +13 lines =@@
       * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
       */
     reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;
->reduce : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
+>reduce : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
 >callbackfn : (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T
 >previousValue : T
 >currentValue : T
@@= skipped -14, +14 lines =@@
       * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
       */
     reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
->reduce : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
+>reduce : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
 >callbackfn : (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U
 >previousValue : U
 >currentValue : T
@@= skipped -14, +14 lines =@@
       * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
       */
     reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;
->reduceRight : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
+>reduceRight : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
 >callbackfn : (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T
 >previousValue : T
 >currentValue : T
@@= skipped -14, +14 lines =@@
       * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
       */
     reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
->reduceRight : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
+>reduceRight : { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
 >callbackfn : (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U
 >previousValue : U
 >currentValue : T
@@= skipped -18, +18 lines =@@
 >n : number
 }
 declare var Array: {
->Array : { (arrayLength?: number): any[]; <T>(arrayLength: number): T[]; <T>(...items: T[]): T[]; new (arrayLength?: number): any[]; new <T>(arrayLength: number): T[]; new <T>(...items: T[]): T[]; isArray(arg: any): boolean; prototype: Array<any>; }
+>Array : ArrayConstructor
 
     new (arrayLength?: number): any[];
 >arrayLength : number
