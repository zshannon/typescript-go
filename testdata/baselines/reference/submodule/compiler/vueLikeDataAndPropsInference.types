//// [tests/cases/compiler/vueLikeDataAndPropsInference.ts] ////

=== vueLikeDataAndPropsInference.ts ===
interface Instance {
>Instance : Instance

    _instanceBrand: never
>_instanceBrand : never
}

type DataDef<Data, Props> = (this: Readonly<Props> & Instance) => Data
>DataDef : DataDef<Data, Props>
>Data : Data
>Props : Props
>this : Readonly<Props> & Instance

type PropsDefinition<T> = {
>PropsDefinition : PropsDefinition<T>
>T : T

    [K in keyof T]: T[K]
>K : K
}

interface Options<
>Options : Options<Data, PropsDef>

    Data = ((this: Instance) => object),
>Data : Data
>this : Instance

    PropsDef = {}
>PropsDef : PropsDef

    > {
    data?: Data
>data : Data

    props?: PropsDef
>props : PropsDef

    watch?: Record<string, WatchHandler<any>>
>watch : Record<string, WatchHandler<any>>
}

type WatchHandler<T> = (val: T, oldVal: T) => void;
>WatchHandler : WatchHandler<T>
>T : T
>val : T
>oldVal : T

type ThisTypedOptions<Data, Props> =
>ThisTypedOptions : ThisTypedOptions<Data, Props>
>Data : Data
>Props : Props

    Options<DataDef<Data, Props>, PropsDefinition<Props>> &
    ThisType<Data & Readonly<Props> & Instance>

declare function test<Data, Props>(fn: ThisTypedOptions<Data, Props>): void;
>test : { <Data, Props>(fn: ThisTypedOptions<Data, Props>): void; (fn: Options<() => object, {}>): void; }
>Data : Data
>Props : Props
>fn : ThisTypedOptions<Data, Props>

declare function test(fn: Options): void;
>test : { <Data, Props>(fn: ThisTypedOptions<Data, Props>): void; (fn: Options<() => object, {}>): void; }
>fn : Options<() => object, {}>

test({
>test({    props: {        foo: ''    },    data(): { bar: boolean } {        return {            bar: true        }    },    watch: {        foo(newVal: string, oldVal: string): void {            this.bar = false        }    }}) : void
>test : { <Data, Props>(fn: ThisTypedOptions<Data, Props>): void; (fn: Options<() => object, {}>): void; }
>{    props: {        foo: ''    },    data(): { bar: boolean } {        return {            bar: true        }    },    watch: {        foo(newVal: string, oldVal: string): void {            this.bar = false        }    }} : { props: { foo: string; }; data: () => { bar: boolean; }; watch: { foo: (newVal: string, oldVal: string) => void; }; }

    props: {
>props : { foo: string; }
>{        foo: ''    } : { foo: string; }

        foo: ''
>foo : string
>'' : ""

    },

    data(): { bar: boolean } {
>data : () => { bar: boolean; }
>bar : boolean

        return {
>{            bar: true        } : { bar: true; }

            bar: true
>bar : true
>true : true
        }
    },

    watch: {
>watch : { foo: (newVal: string, oldVal: string) => void; }
>{        foo(newVal: string, oldVal: string): void {            this.bar = false        }    } : { foo: (newVal: string, oldVal: string) => void; }

        foo(newVal: string, oldVal: string): void {
>foo : (newVal: string, oldVal: string) => void
>newVal : string
>oldVal : string

            this.bar = false
>this.bar = false : false
>this.bar : any
>this : any
>bar : any
>false : false
        }
    }
})
