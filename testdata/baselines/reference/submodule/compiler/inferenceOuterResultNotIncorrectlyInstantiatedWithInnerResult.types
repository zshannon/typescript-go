//// [tests/cases/compiler/inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts] ////

=== inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts ===
// simple example
export class Test<A, B> {
>Test : Test<A, B>
>A : A
>B : B

    constructor(public a: A, public b: B) { }
>a : A
>b : B

    test<C>(c: C): Test<B, C> {
>test : <C>(c: C) => Test<B, C>
>C : C
>c : C

        return new Test(this.b, c);
>new Test(this.b, c) : Test<B, C>
>Test : typeof Test
>this.b : B
>this : this
>b : B
>c : C
    }
}

// complicated one
interface Supervisor<out T> {
>Supervisor : Supervisor<T>
>T : T

    zip<A>(right: Supervisor<A>): Supervisor<[T, A]>;
>zip : <A>(right: Supervisor<A>) => Supervisor<[T, A]>
>A : A
>right : Supervisor<A>
}

export class Zip<out T0, out T1> implements Supervisor<readonly [T0, T1]> {
>Zip : Zip<T0, T1>
>T0 : T0
>T1 : T1

    constructor(
        readonly left: Supervisor<T0>,
>left : Supervisor<T0>

        readonly right: Supervisor<T1>,
>right : Supervisor<T1>

    ) { }

    zip<A>(right: Supervisor<A>): Supervisor<[[T0, T1], A]> {
>zip : <A>(right: Supervisor<A>) => Supervisor<[[T0, T1], A]>
>A : A
>right : Supervisor<A>

        return new Zip(this, right);
>new Zip(this, right) : Zip<[T0, T1], A>
>Zip : typeof Zip
>this : this
>right : Supervisor<A>
    }
}

// indirect
type Assign<T, U> = Omit<T, keyof U> & U;
>Assign : Assign<T, U>
>T : T
>U : U

class Base<T> {
>Base : Base<T>
>T : T

    constructor(public t: T) { }
>t : T
}

export class Foo<T> extends Base<T> {
>Foo : Foo<T>
>T : T
>Base : Base<T>

    update(): Foo<Assign<T, { x: number }>> {
>update : () => Foo<Assign<T, { x: number; }>>
>x : number

        const v: Assign<T, { x: number }> = Object.assign(this.t, { x: 1 });
>v : Assign<T, { x: number; }>
>x : number
>Object.assign(this.t, { x: 1 }) : T & { x: number; }
>Object.assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
>Object : ObjectConstructor
>assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
>this.t : T
>this : this
>t : T
>{ x: 1 } : { x: number; }
>x : number
>1 : 1

        return new Foo(v);
>new Foo(v) : Foo<Assign<T, { x: number; }>>
>Foo : typeof Foo
>v : Assign<T, { x: number; }>
    }
}
