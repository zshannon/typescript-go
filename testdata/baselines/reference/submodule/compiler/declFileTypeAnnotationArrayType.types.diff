--- old.declFileTypeAnnotationArrayType.types
+++ new.declFileTypeAnnotationArrayType.types
@@= skipped -11, +11 lines =@@
     }
     export class g<T> {
 >g : g<T>
+>T : T
     }
 }
 class g<T> {
 >g : g<T>
+>T : T
 }
 
 // Just the name
@@= skipped -26, +28 lines =@@
 
 // Qualified name
 function foo3(): m.c[] {
->foo3 : () => m.c[]
+>foo3 : () => c[]
 >m : any
 
     return [new m.c()];
->[new m.c()] : m.c[]
->new m.c() : m.c
->m.c : typeof m.c
+>[new m.c()] : c[]
+>new m.c() : c
+>m.c : typeof c
 >m : typeof m
->c : typeof m.c
+>c : typeof c
 }
 function foo4() {
->foo4 : () => typeof m.c
+>foo4 : () => typeof c
 
     return m.c;
->m.c : typeof m.c
+>m.c : typeof c
 >m : typeof m
->c : typeof m.c
+>c : typeof c
 }
 
 // Just the name with type arguments
@@= skipped -39, +39 lines =@@
 
 // Qualified name with type arguments
 function foo7(): m.g<number>[] {
->foo7 : () => m.g<number>[]
+>foo7 : () => g<number>[]
 >m : any
 
     return [new m.g<number>()];
->[new m.g<number>()] : m.g<number>[]
->new m.g<number>() : m.g<number>
->m.g : typeof m.g
+>[new m.g<number>()] : g<number>[]
+>new m.g<number>() : g<number>
+>m.g : typeof g
 >m : typeof m
->g : typeof m.g
+>g : typeof g
 }
 function foo8() {
->foo8 : () => m.g<number>[]
+>foo8 : () => g<number>[]
 
     return [new m.g<number>()];
->[new m.g<number>()] : m.g<number>[]
->new m.g<number>() : m.g<number>
->m.g : typeof m.g
+>[new m.g<number>()] : g<number>[]
+>new m.g<number>() : g<number>
+>m.g : typeof g
 >m : typeof m
->g : typeof m.g
+>g : typeof g
 }
 
 // Array of function types
 function foo9(): (()=>c)[] {
->foo9 : () => (() => c)[]
+>foo9 : () => () => c[]
 
     return [() => new c()];
->[() => new c()] : (() => c)[]
+>[() => new c()] : () => c[]
 >() => new c() : () => c
 >new c() : c
 >c : typeof c
 }
 function foo10() {
->foo10 : () => (() => c)[]
+>foo10 : () => () => c[]
 
     return [() => new c()];
->[() => new c()] : (() => c)[]
+>[() => new c()] : () => c[]
 >() => new c() : () => c
 >new c() : c
 >c : typeof c
