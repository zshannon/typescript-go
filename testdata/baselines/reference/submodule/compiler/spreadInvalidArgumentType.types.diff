--- old.spreadInvalidArgumentType.types
+++ new.spreadInvalidArgumentType.types
@@= skipped -7, +7 lines =@@
 
 function f<T extends { b: string }>(p1: T, p2: T[]) {
 >f : <T extends { b: string; }>(p1: T, p2: T[]) => void
+>T : T
 >b : string
 >p1 : T
 >p2 : T[]
@@= skipped -14, +15 lines =@@
 >k : keyof T
 
     var mapped_generic: {[P in keyof T]: T[P]};
->mapped_generic : { [P in keyof T]: T[P]; }
+>mapped_generic : { [P in keyof T]: T[P] }
+>P : P
 
     var mapped: {[P in "b"]: T[P]};
 >mapped : { b: T["b"]; }
+>P : P
 
     var union_generic: T | { a: number };
 >union_generic : T | { a: number; }
@@= skipped -52, +54 lines =@@
 >p1 : T
 
     var o2 = { ...p2 };  // OK
->o2 : { [x: number]: T; length: number; toString(): string; toLocaleString(): string; pop(): T; push(...items: T[]): number; concat(...items: ConcatArray<T>[]): T[]; concat(...items: (T | ConcatArray<T>)[]): T[]; join(separator?: string): string; reverse(): T[]; shift(): T; slice(start?: number, end?: number): T[]; sort(compareFn?: (a: T, b: T) => number): T[]; splice(start: number, deleteCount?: number): T[]; splice(start: number, deleteCount: number, ...items: T[]): T[]; unshift(...items: T[]): number; indexOf(searchElement: T, fromIndex?: number): number; lastIndexOf(searchElement: T, fromIndex?: number): number; every<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; some(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[]; filter<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
->{ ...p2 } : { [n: number]: T; length: number; toString(): string; toLocaleString(): string; pop(): T; push(...items: T[]): number; concat(...items: ConcatArray<T>[]): T[]; concat(...items: (T | ConcatArray<T>)[]): T[]; join(separator?: string): string; reverse(): T[]; shift(): T; slice(start?: number, end?: number): T[]; sort(compareFn?: (a: T, b: T) => number): T[]; splice(start: number, deleteCount?: number): T[]; splice(start: number, deleteCount: number, ...items: T[]): T[]; unshift(...items: T[]): number; indexOf(searchElement: T, fromIndex?: number): number; lastIndexOf(searchElement: T, fromIndex?: number): number; every<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; some(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[]; filter<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }
+>o2 : { [n: number]: T; length: number; toString: () => string; toLocaleString: () => string; pop: () => T; push: (...items: T[]) => number; concat: { (...items: ConcatArray<T>[]): T[]; (...items: (T | ConcatArray<T>)[]): T[]; }; join: (separator?: string) => string; reverse: () => T[]; shift: () => T; slice: (start?: number, end?: number) => T[]; sort: (compareFn?: (a: T, b: T) => number) => T[]; splice: { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }; unshift: (...items: T[]) => number; indexOf: (searchElement: T, fromIndex?: number) => number; lastIndexOf: (searchElement: T, fromIndex?: number) => number; every: { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; }; some: (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any) => boolean; forEach: (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) => void; map: <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]; filter: { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; }; reduce: { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }; reduceRight: { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }; }
+>{ ...p2 } : { [n: number]: T; length: number; toString: () => string; toLocaleString: () => string; pop: () => T; push: (...items: T[]) => number; concat: { (...items: ConcatArray<T>[]): T[]; (...items: (T | ConcatArray<T>)[]): T[]; }; join: (separator?: string) => string; reverse: () => T[]; shift: () => T; slice: (start?: number, end?: number) => T[]; sort: (compareFn?: (a: T, b: T) => number) => T[]; splice: { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }; unshift: (...items: T[]) => number; indexOf: (searchElement: T, fromIndex?: number) => number; lastIndexOf: (searchElement: T, fromIndex?: number) => number; every: { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean; }; some: (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any) => boolean; forEach: (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) => void; map: <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]; filter: { <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; }; reduce: { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }; reduceRight: { (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }; }
 >p2 : T[]
 
     var o3 = { ...t };   // OK, generic type paramter
@@= skipped -20, +20 lines =@@
 >k : keyof T
 
     var o6 = { ...mapped_generic }; // OK, generic mapped object type
->o6 : { [P in keyof T]: T[P]; }
->{ ...mapped_generic } : { [P in keyof T]: T[P]; }
->mapped_generic : { [P in keyof T]: T[P]; }
+>o6 : { [P in keyof T]: T[P] }
+>{ ...mapped_generic } : { [P in keyof T]: T[P] }
+>mapped_generic : { [P in keyof T]: T[P] }
 
     var o7 = { ...mapped };  // OK, non-generic mapped type
 >o7 : { b: T["b"]; }
