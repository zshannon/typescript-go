--- old.genericDefaults.types
+++ new.genericDefaults.types
@@= skipped -83, +83 lines =@@
 
 // function with a type paramter with a default
 declare function f02<T = A>(a?: T): T;
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 >a : T
 
 // inference
 f02();
 >f02() : A
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 
 f02(a);
 >f02(a) : A
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 >a : A
 
 f02(b);
 >f02(b) : B
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 >b : B
 
 // no inference, fully supplied
 f02<A>();
 >f02<A>() : A
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 
 f02<A>(a);
 >f02<A>(a) : A
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 >a : A
 
 f02<B>();
 >f02<B>() : B
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 
 f02<B>(b);
 >f02<B>(b) : B
->f02 : <T = A>(a?: T) => T
+>f02 : <T>(a?: T) => T
 >b : B
 
 // function with a type parameter with a default that refers to itself
 declare function f03<T = T>(a?: T): T;
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 >a : T
 
 // inference
 f03();
 >f03() : unknown
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 
 f03(a);
 >f03(a) : A
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 >a : A
 
 f03(b);
 >f03(b) : B
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 >b : B
 
 // no inference, fully supplied
 f03<A>();
 >f03<A>() : A
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 
 f03<A>(a);
 >f03<A>(a) : A
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 >a : A
 
 f03<B>();
 >f03<B>() : B
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 
 f03<B>(b);
 >f03<B>(b) : B
->f03 : <T = T>(a?: T) => T
+>f03 : <T>(a?: T) => T
 >b : B
 
 // function with a type paramter without a default and a type parameter with a default
 declare function f04<T, U = B>(a?: T, b?: U): [T, U];
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f04();
 >f04() : [unknown, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 
 f04(a);
 >f04(a) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f04(a, b);
 >f04(a, b) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f04(a, c);
 >f04(a, c) : [A, C]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f04<A>();
 >f04<A>() : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 
 f04<A>(a);
 >f04<A>(a) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f04<A>(a, b);
 >f04<A>(a, b) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, fully supplied
 f04<A, B>();
 >f04<A, B>() : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 
 f04<A, B>(a);
 >f04<A, B>(a) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f04<A, B>(a, b);
 >f04<A, B>(a, b) : [A, B]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f04<A, C>();
 >f04<A, C>() : [A, C]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 
 f04<A, C>(a);
 >f04<A, C>(a) : [A, C]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f04<A, C>(a, c);
 >f04<A, C>(a, c) : [A, C]
->f04 : <T, U = B>(a?: T, b?: U) => [T, U]
+>f04 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter without a default and a type parameter with a default that refers to an earlier type parameter
 declare function f05<T, U = T>(a?: T, b?: U): [T, U];
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f05();
 >f05() : [unknown, unknown]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 
 f05(a);
 >f05(a) : [A, A]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f05(a, a);
 >f05(a, a) : [A, A]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f05(a, b);
 >f05(a, b) : [A, B]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, partially supplied
 f05<A>();
 >f05<A>() : [A, A]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 
 f05<A>(a);
 >f05<A>(a) : [A, A]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f05<A>(a, a);
 >f05<A>(a, a) : [A, A]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 // no inference, fully supplied
 f05<A, B>();
 >f05<A, B>() : [A, B]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 
 f05<A, B>(a);
 >f05<A, B>(a) : [A, B]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f05<A, B>(a, b);
 >f05<A, B>(a, b) : [A, B]
->f05 : <T, U = T>(a?: T, b?: U) => [T, U]
+>f05 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // function with a type parameter with a default that refers to an earlier type parameter with a default
 declare function f06<T = A, U = T>(a?: T, b?: U): [T, U];
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f06();
 >f06() : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 
 f06(a);
 >f06(a) : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f06(a, a);
 >f06(a, a) : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f06(a, b);
 >f06(a, b) : [A, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f06(b, a);
 >f06(b, a) : [B, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 >a : A
 
 f06(b, b);
 >f06(b, b) : [B, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 >b : B
 
 // no inference, partially supplied
 f06<A>();
 >f06<A>() : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 
 f06<A>(a);
 >f06<A>(a) : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f06<A>(a, a);
 >f06<A>(a, a) : [A, A]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f06<B>();
 >f06<B>() : [B, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 
 f06<B>(b);
 >f06<B>(b) : [B, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 
 f06<B>(b, b);
 >f06<B>(b, b) : [B, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 >b : B
 
 // no inference, fully supplied
 f06<A, B>();
 >f06<A, B>() : [A, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 
 f06<A, B>(a);
 >f06<A, B>(a) : [A, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f06<A, B>(a, b);
 >f06<A, B>(a, b) : [A, B]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f06<B, C>();
 >f06<B, C>() : [B, C]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 
 f06<B, C>(b);
 >f06<B, C>(b) : [B, C]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 
 f06<B, C>(b, c);
 >f06<B, C>(b, c) : [B, C]
->f06 : <T = A, U = T>(a?: T, b?: U) => [T, U]
+>f06 : <T, U>(a?: T, b?: U) => [T, U]
 >b : B
 >c : C
 
 // function with a type parameter without a default and a type parameter with a default that refers to an earlier type parameter with a default
 declare function f07<T, U = B, V = U>(a?: T, b?: U, c?: V): [T, U, V];
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : T
 >b : U
 >c : V
@@= skipped -323, +323 lines =@@
 // inference
 f07();
 >f07() : [unknown, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07(a, b);
 >f07(a, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f07(a, c);
 >f07(a, c) : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 
 f07(a, b, b);
 >f07(a, b, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f07(a, b, c);
 >f07(a, b, c) : [A, B, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
 
 f07(a, c, b);
 >f07(a, c, b) : [A, C, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 >b : B
 
 f07(a, c, c);
 >f07(a, c, c) : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 >c : C
@@= skipped -45, +45 lines =@@
 // no inference, partially supplied
 f07<A>();
 >f07<A>() : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07<A>(a);
 >f07<A>(a) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f07<A>(a, b);
 >f07<A>(a, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f07<A>(a, b, b);
 >f07<A>(a, b, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f07<A, B>();
 >f07<A, B>() : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07<A, B>(a);
 >f07<A, B>(a) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f07<A, B>(a, b);
 >f07<A, B>(a, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f07<A, B>(a, b, b);
 >f07<A, B>(a, b, b) : [A, B, B]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f07<A, C>();
 >f07<A, C>() : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07<A, C>(a);
 >f07<A, C>(a) : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f07<A, C>(a, c);
 >f07<A, C>(a, c) : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 
 f07<A, C>(a, c, c);
 >f07<A, C>(a, c, c) : [A, C, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 >c : C
@@= skipped -67, +67 lines =@@
 // no inference, fully supplied
 f07<A, B, C>();
 >f07<A, B, C>() : [A, B, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07<A, B, C>(a);
 >f07<A, B, C>(a) : [A, B, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f07<A, B, C>(a, b);
 >f07<A, B, C>(a, b) : [A, B, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f07<A, B, C>(a, b, c);
 >f07<A, B, C>(a, b, c) : [A, B, C]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
 
 f07<A, C, A>();
 >f07<A, C, A>() : [A, C, A]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f07<A, C, A>(a);
 >f07<A, C, A>(a) : [A, C, A]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f07<A, C, D>(a, c);
 >f07<A, C, D>(a, c) : [A, C, D]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 
 f07<A, C, D>(a, c, d);
 >f07<A, C, D>(a, c, d) : [A, C, D]
->f07 : <T, U = B, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f07 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >c : C
 >d : D
 
 // function with a type parameter with a default that refers to an earlier type parameter with a constraint
 declare function f08<T extends A, U = T>(a?: T, b?: U): [T, U];
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f08();
 >f08() : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 
 f08(a);
 >f08(a) : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f08(a, a);
 >f08(a, a) : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f08(a, b);
 >f08(a, b) : [A, B]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, partially supplied
 f08<A>();
 >f08<A>() : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 
 f08<A>(a);
 >f08<A>(a) : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f08<A>(a, a);
 >f08<A>(a, a) : [A, A]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 // no inference, fully supplied
 f08<A, B>();
 >f08<A, B>() : [A, B]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 
 f08<A, B>(a);
 >f08<A, B>(a) : [A, B]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f08<A, B>(a, b);
 >f08<A, B>(a, b) : [A, B]
->f08 : <T extends A, U = T>(a?: T, b?: U) => [T, U]
+>f08 : <T extends A, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // function with a type parameter with a constraint and a default that refers to an earlier type parameter
 declare function f09<T, U extends T = T>(a?: T, b?: U): [T, U];
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f09();
 >f09() : [unknown, unknown]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 
 f09(a);
 >f09(a) : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f09(a, a);
 >f09(a, a) : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f09(a, ab);
 >f09(a, ab) : [A, AB]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, partially supplied
 f09<A>();
 >f09<A>() : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 
 f09<A>(a);
 >f09<A>(a) : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f09<A>(a, a);
 >f09<A>(a, a) : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f09<A>(a, ab);
 >f09<A>(a, ab) : [A, A]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, fully supplied
 f09<A, AB>();
 >f09<A, AB>() : [A, AB]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 
 f09<A, AB>(a);
 >f09<A, AB>(a) : [A, AB]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f09<A, AB>(a, ab);
 >f09<A, AB>(a, ab) : [A, AB]
->f09 : <T, U extends T = T>(a?: T, b?: U) => [T, U]
+>f09 : <T, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // function with a type parameter with a constraint and a default that refers to an earlier type parameter with a constraint
 declare function f10<T extends A, U extends T = T>(a?: T, b?: U): [T, U];
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f10();
 >f10() : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 
 f10(a);
 >f10(a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f10(a, a);
 >f10(a, a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f10(a, ab);
 >f10(a, ab) : [A, AB]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, partially supplied
 f10<A>();
 >f10<A>() : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 
 f10<A>(a);
 >f10<A>(a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f10<A>(a, a);
 >f10<A>(a, a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f10<A>(a, ab);
 >f10<A>(a, ab) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, fully supplied
 f10<A, A>();
 >f10<A, A>() : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 
 f10<A, A>(a);
 >f10<A, A>(a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f10<A, A>(a, a);
 >f10<A, A>(a, a) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f10<A, A>(a, ab);
 >f10<A, A>(a, ab) : [A, A]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 f10<A, AB>();
 >f10<A, AB>() : [A, AB]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 
 f10<A, AB>(a);
 >f10<A, AB>(a) : [A, AB]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 
 f10<A, AB>(a, ab);
 >f10<A, AB>(a, ab) : [A, AB]
->f10 : <T extends A, U extends T = T>(a?: T, b?: U) => [T, U]
+>f10 : <T extends A, U extends T>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // function with a type parameter with a default that refers to an earier type parameter in a union
 declare function f11<T, U = T | B>(a?: T, b?: U): [T, U];
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f11();
 >f11() : [unknown, unknown]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 
 f11(a);
 >f11(a) : [A, A | B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f11(a, a);
 >f11(a, a) : [A, A]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f11(a, b);
 >f11(a, b) : [A, B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f11(a, c);
 >f11(a, c) : [A, C]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f11<A>();
 >f11<A>() : [A, A | B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 
 f11<A>(a);
 >f11<A>(a) : [A, A | B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f11<A>(a, a);
 >f11<A>(a, a) : [A, A | B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f11<A>(a, b);
 >f11<A>(a, b) : [A, A | B]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, fully supplied
 f11<A, C>();
 >f11<A, C>() : [A, C]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 
 f11<A, C>(a);
 >f11<A, C>(a) : [A, C]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f11<A, C>(a, c);
 >f11<A, C>(a, c) : [A, C]
->f11 : <T, U = T | B>(a?: T, b?: U) => [T, U]
+>f11 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter with a default that refers to an earlier type parameter in an intersection
 declare function f12<T, U = T & B>(a?: T, b?: U): [T, U];
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f12();
 >f12() : [unknown, B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 
 f12(a);
 >f12(a) : [A, A & B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f12(a, a);
 >f12(a, a) : [A, A]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f12(a, b);
 >f12(a, b) : [A, B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f12(a, c);
 >f12(a, c) : [A, C]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f12<A>();
 >f12<A>() : [A, A & B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 
 f12<A>(a);
 >f12<A>(a) : [A, A & B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f12<A>(a, ab);
 >f12<A>(a, ab) : [A, A & B]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, fully supplied
 f12<A, C>();
 >f12<A, C>() : [A, C]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 
 f12<A, C>(a);
 >f12<A, C>(a) : [A, C]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f12<A, C>(a, c);
 >f12<A, C>(a, c) : [A, C]
->f12 : <T, U = T & B>(a?: T, b?: U) => [T, U]
+>f12 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter with a default that refers to a later type parameter with a default
 declare function f13<T = U, U = B>(a?: T, b?: U): [T, U];
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f13();
 >f13() : [unknown, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 
 f13(a);
 >f13(a) : [A, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f13(a, b);
 >f13(a, b) : [A, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f13(a, c);
 >f13(a, c) : [A, C]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f13<A>();
 >f13<A>() : [A, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 
 f13<A>(a);
 >f13<A>(a) : [A, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f13<A>(a, b);
 >f13<A>(a, b) : [A, B]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, fully supplied
 f13<A, C>();
 >f13<A, C>() : [A, C]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 
 f13<A, C>(a);
 >f13<A, C>(a) : [A, C]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f13<A, C>(a, c);
 >f13<A, C>(a, c) : [A, C]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 f13<A, C>(a, c);
 >f13<A, C>(a, c) : [A, C]
->f13 : <T = U, U = B>(a?: T, b?: U) => [T, U]
+>f13 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter without a default and a type parameter with a default that refers to a later type parameter with a default
 declare function f14<T, U = V, V = C>(a?: T, b?: U, c?: V): [T, U, V];
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : T
 >b : U
 >c : V
@@= skipped -469, +469 lines =@@
 // inference
 f14();
 >f14() : [unknown, unknown, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f14(a);
 >f14(a) : [A, unknown, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f14(a, b);
 >f14(a, b) : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f14(a, b, c);
 >f14(a, b, c) : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
 
 f14(a, b, d);
 >f14(a, b, d) : [A, B, D]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >d : D
@@= skipped -30, +30 lines =@@
 // no inference, partially supplied
 f14<A>();
 >f14<A>() : [A, any, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f14<A>(a);
 >f14<A>(a) : [A, any, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f14<A>(a, b);
 >f14<A>(a, b) : [A, any, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f14<A>(a, b, c);
 >f14<A>(a, b, c) : [A, any, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
 
 f14<A, B>();
 >f14<A, B>() : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f14<A, B>(a);
 >f14<A, B>(a) : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f14<A, B>(a, b);
 >f14<A, B>(a, b) : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f14<A, B>(a, b, c);
 >f14<A, B>(a, b, c) : [A, B, C]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
@@= skipped -45, +45 lines =@@
 // no inference fully supplied
 f14<A, B, D>();
 >f14<A, B, D>() : [A, B, D]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f14<A, B, D>(a);
 >f14<A, B, D>(a) : [A, B, D]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f14<A, B, D>(a, b);
 >f14<A, B, D>(a, b) : [A, B, D]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f14<A, B, D>(a, b, d);
 >f14<A, B, D>(a, b, d) : [A, B, D]
->f14 : <T, U = V, V = C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f14 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >d : D
 
 // function with two type parameters with defaults that mutually refer to each other
 declare function f15<T = U, U = T>(a?: T, b?: U): [T, U];
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f15();
 >f15() : [unknown, unknown]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 
 f15(a);
 >f15(a) : [A, A]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f15(a, b);
 >f15(a, b) : [A, B]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, partially supplied
 f15<A>();
 >f15<A>() : [A, A]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 
 f15<A>(a);
 >f15<A>(a) : [A, A]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f15<A>(a, a);
 >f15<A>(a, a) : [A, A]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 // no inference, fully supplied
 f15<A, B>();
 >f15<A, B>() : [A, B]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 
 f15<A, B>(a);
 >f15<A, B>(a) : [A, B]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f15<A, B>(a, b);
 >f15<A, B>(a, b) : [A, B]
->f15 : <T = U, U = T>(a?: T, b?: U) => [T, U]
+>f15 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // function with a type parameter without a default and two type parameters with defaults that mutually refer to each other
 declare function f16<T, U = V, V = U>(a?: T, b?: U, c?: V): [T, U, V];
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : T
 >b : U
 >c : V
@@= skipped -84, +84 lines =@@
 // no inference
 f16();
 >f16() : [unknown, unknown, unknown]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f16(a);
 >f16(a) : [A, unknown, unknown]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f16(a, b);
 >f16(a, b) : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f16(a, b, b);
 >f16(a, b, b) : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
@@= skipped -23, +23 lines =@@
 // no inference, partially supplied
 f16<A>();
 >f16<A>() : [A, any, any]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f16<A>(a);
 >f16<A>(a) : [A, any, any]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f16<A>(a, b);
 >f16<A>(a, b) : [A, any, any]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f16<A>(a, b, b);
 >f16<A>(a, b, b) : [A, any, any]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f16<A, B>();
 >f16<A, B>() : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f16<A, B>(a);
 >f16<A, B>(a) : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f16<A, B>(a, b);
 >f16<A, B>(a, b) : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f16<A, B>(a, b, b);
 >f16<A, B>(a, b, b) : [A, B, B]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
@@= skipped -45, +45 lines =@@
 // no inference, fully supplied
 f16<A, B, D>();
 >f16<A, B, D>() : [A, B, D]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f16<A, B, D>(a);
 >f16<A, B, D>(a) : [A, B, D]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f16<A, B, D>(a, b);
 >f16<A, B, D>(a, b) : [A, B, D]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f16<A, B, D>(a, b, d);
 >f16<A, B, D>(a, b, d) : [A, B, D]
->f16 : <T, U = V, V = U>(a?: T, b?: U, c?: V) => [T, U, V]
+>f16 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >d : D
 
 // function with a type parameter with a default that refers to a later type parameter with a default that refers to an earlier type parameter in a union
 declare function f17<T = U, U = T | B>(a?: T, b?: U): [T, U];
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f17();
 >f17() : [unknown, unknown]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 
 f17(a);
 >f17(a) : [A, A | B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f17(a, a);
 >f17(a, a) : [A, A]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f17(a, b);
 >f17(a, b) : [A, B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f17(a, c);
 >f17(a, c) : [A, C]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f17<A>();
 >f17<A>() : [A, A | B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 
 f17<A>(a);
 >f17<A>(a) : [A, A | B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f17<A>(a, a);
 >f17<A>(a, a) : [A, A | B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f17<A>(a, b);
 >f17<A>(a, b) : [A, A | B]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 // no inference, fully supplied
 f17<A, C>();
 >f17<A, C>() : [A, C]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 
 f17<A, C>(a);
 >f17<A, C>(a) : [A, C]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f17<A, C>(a, c);
 >f17<A, C>(a, c) : [A, C]
->f17 : <T = U, U = T | B>(a?: T, b?: U) => [T, U]
+>f17 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter without a default and a type parameter with a default that refers to a later type parameter with a default that refers to an earlier type parameter in a union
 declare function f18<T, U = V, V = U | C>(a?: T, b?: U, c?: V): [T, U, V];
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : T
 >b : U
 >c : V
@@= skipped -102, +102 lines =@@
 // inference
 f18();
 >f18() : [unknown, unknown, unknown]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f18(a);
 >f18(a) : [A, unknown, unknown]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f18(a, b);
 >f18(a, b) : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f18(a, b, b);
 >f18(a, b, b) : [A, B, B]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f18(a, b, c);
 >f18(a, b, c) : [A, B, C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
@@= skipped -30, +30 lines =@@
 // no inference, partially supplied
 f18<A>();
 >f18<A>() : [A, any, any]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f18<A>(a);
 >f18<A>(a) : [A, any, any]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f18<A>(a, b);
 >f18<A>(a, b) : [A, any, any]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f18<A>(a, b, b);
 >f18<A>(a, b, b) : [A, any, any]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f18<A>(a, b, c);
 >f18<A>(a, b, c) : [A, any, any]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
 
 f18<A, B>();
 >f18<A, B>() : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f18<A, B>(a);
 >f18<A, B>(a) : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f18<A, B>(a, b);
 >f18<A, B>(a, b) : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f18<A, B>(a, b, b);
 >f18<A, B>(a, b, b) : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >b : B
 
 f18<A, B>(a, b, c);
 >f18<A, B>(a, b, c) : [A, B, B | C]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
@@= skipped -59, +59 lines =@@
 // no inference, fully supplied
 f18<A, B, D>();
 >f18<A, B, D>() : [A, B, D]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f18<A, B, D>(a);
 >f18<A, B, D>(a) : [A, B, D]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f18<A, B, D>(a, b);
 >f18<A, B, D>(a, b) : [A, B, D]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f18<A, B, D>(a, b, d);
 >f18<A, B, D>(a, b, d) : [A, B, D]
->f18 : <T, U = V, V = U | C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f18 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >d : D
 
 // function with a type parameter with a default that refers to a later type parameter with a default that refers to an earlier type parameter in an intersection
 declare function f19<T = U, U = T & B>(a?: T, b?: U): [T, U];
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : T
 >b : U
 
 // inference
 f19();
 >f19() : [unknown, B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 
 f19(a);
 >f19(a) : [A, A & B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f19(a, a);
 >f19(a, a) : [A, A]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >a : A
 
 f19(a, b);
 >f19(a, b) : [A, B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >b : B
 
 f19(a, ab);
 >f19(a, ab) : [A, AB]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 f19(a, c);
 >f19(a, c) : [A, C]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // no inference, partially supplied
 f19<A>();
 >f19<A>() : [A, A & B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 
 f19<A>(a);
 >f19<A>(a) : [A, A & B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f19<A>(a, ab);
 >f19<A>(a, ab) : [A, A & B]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >ab : AB
 
 // no inference, fully supplied
 f19<A, C>();
 >f19<A, C>() : [A, C]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 
 f19<A, C>(a);
 >f19<A, C>(a) : [A, C]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 
 f19<A, C>(a, c);
 >f19<A, C>(a, c) : [A, C]
->f19 : <T = U, U = T & B>(a?: T, b?: U) => [T, U]
+>f19 : <T, U>(a?: T, b?: U) => [T, U]
 >a : A
 >c : C
 
 // function with a type parameter without a default and a type parameter with a default that refers to a later type parameter with a default that refers to an earlier type parameter in an intersection
 declare function f20<T, U = V, V = U & C>(a?: T, b?: U, c?: V): [T, U, V];
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : T
 >b : U
 >c : V
@@= skipped -102, +102 lines =@@
 // inference
 f20();
 >f20() : [unknown, unknown, C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f20(a);
 >f20(a) : [A, unknown, C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f20(a, b);
 >f20(a, b) : [A, B, B & C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f20(a, b, c);
 >f20(a, b, c) : [A, B, C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >c : C
@@= skipped -23, +23 lines =@@
 // no inference, partially supplied
 f20<A>();
 >f20<A>() : [A, any, any]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f20<A>(a);
 >f20<A>(a) : [A, any, any]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f20<A>(a, b);
 >f20<A>(a, b) : [A, any, any]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f20<A>(a, b, bc);
 >f20<A>(a, b, bc) : [A, any, any]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >bc : BC
 
 f20<A, B>();
 >f20<A, B>() : [A, B, B & C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f20<A, B>(a);
 >f20<A, B>(a) : [A, B, B & C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f20<A, B>(a, b);
 >f20<A, B>(a, b) : [A, B, B & C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f20<A, B>(a, b, bc);
 >f20<A, B>(a, b, bc) : [A, B, B & C]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >bc : BC
@@= skipped -45, +45 lines =@@
 // no inference, fully supplied
 f20<A, B, D>();
 >f20<A, B, D>() : [A, B, D]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 
 f20<A, B, D>(a);
 >f20<A, B, D>(a) : [A, B, D]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 
 f20<A, B, D>(a, b);
 >f20<A, B, D>(a, b) : [A, B, D]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 
 f20<A, B, D>(a, b, d);
 >f20<A, B, D>(a, b, d) : [A, B, D]
->f20 : <T, U = V, V = U & C>(a?: T, b?: U, c?: V) => [T, U, V]
+>f20 : <T, U, V>(a?: T, b?: U, c?: V) => [T, U, V]
 >a : A
 >b : B
 >d : D
@@= skipped -196, +196 lines =@@
 >a : [number, string]
 
 interface i07 { a: A; }
->a : globalThis.A
+>a : A
 
 interface i07<A = number> { b: A; }
 >b : A
