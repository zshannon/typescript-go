// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package vfsmock

import (
	"sync"

	"github.com/microsoft/typescript-go/internal/vfs"
)

// Ensure, that FSMock does implement vfs.FS.
// If this is not the case, regenerate this file with moq.
var _ vfs.FS = &FSMock{}

// FSMock is a mock implementation of vfs.FS.
//
//	func TestSomethingThatUsesFS(t *testing.T) {
//
//		// make and configure a mocked vfs.FS
//		mockedFS := &FSMock{
//			DirectoryExistsFunc: func(path string) bool {
//				panic("mock out the DirectoryExists method")
//			},
//			FileExistsFunc: func(path string) bool {
//				panic("mock out the FileExists method")
//			},
//			GetAccessibleEntriesFunc: func(path string) vfs.Entries {
//				panic("mock out the GetAccessibleEntries method")
//			},
//			ReadFileFunc: func(path string) (string, bool) {
//				panic("mock out the ReadFile method")
//			},
//			RealpathFunc: func(path string) string {
//				panic("mock out the Realpath method")
//			},
//			RemoveFunc: func(path string) error {
//				panic("mock out the Remove method")
//			},
//			StatFunc: func(path string) vfs.FileInfo {
//				panic("mock out the Stat method")
//			},
//			UseCaseSensitiveFileNamesFunc: func() bool {
//				panic("mock out the UseCaseSensitiveFileNames method")
//			},
//			WalkDirFunc: func(root string, walkFn vfs.WalkDirFunc) error {
//				panic("mock out the WalkDir method")
//			},
//			WriteFileFunc: func(path string, data string, writeByteOrderMark bool) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedFS in code that requires vfs.FS
//		// and then make assertions.
//
//	}
type FSMock struct {
	// DirectoryExistsFunc mocks the DirectoryExists method.
	DirectoryExistsFunc func(path string) bool

	// FileExistsFunc mocks the FileExists method.
	FileExistsFunc func(path string) bool

	// GetAccessibleEntriesFunc mocks the GetAccessibleEntries method.
	GetAccessibleEntriesFunc func(path string) vfs.Entries

	// ReadFileFunc mocks the ReadFile method.
	ReadFileFunc func(path string) (string, bool)

	// RealpathFunc mocks the Realpath method.
	RealpathFunc func(path string) string

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(path string) error

	// StatFunc mocks the Stat method.
	StatFunc func(path string) vfs.FileInfo

	// UseCaseSensitiveFileNamesFunc mocks the UseCaseSensitiveFileNames method.
	UseCaseSensitiveFileNamesFunc func() bool

	// WalkDirFunc mocks the WalkDir method.
	WalkDirFunc func(root string, walkFn vfs.WalkDirFunc) error

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(path string, data string, writeByteOrderMark bool) error

	// calls tracks calls to the methods.
	calls struct {
		// DirectoryExists holds details about calls to the DirectoryExists method.
		DirectoryExists []struct {
			// Path is the path argument value.
			Path string
		}
		// FileExists holds details about calls to the FileExists method.
		FileExists []struct {
			// Path is the path argument value.
			Path string
		}
		// GetAccessibleEntries holds details about calls to the GetAccessibleEntries method.
		GetAccessibleEntries []struct {
			// Path is the path argument value.
			Path string
		}
		// ReadFile holds details about calls to the ReadFile method.
		ReadFile []struct {
			// Path is the path argument value.
			Path string
		}
		// Realpath holds details about calls to the Realpath method.
		Realpath []struct {
			// Path is the path argument value.
			Path string
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Path is the path argument value.
			Path string
		}
		// Stat holds details about calls to the Stat method.
		Stat []struct {
			// Path is the path argument value.
			Path string
		}
		// UseCaseSensitiveFileNames holds details about calls to the UseCaseSensitiveFileNames method.
		UseCaseSensitiveFileNames []struct {
		}
		// WalkDir holds details about calls to the WalkDir method.
		WalkDir []struct {
			// Root is the root argument value.
			Root string
			// WalkFn is the walkFn argument value.
			WalkFn vfs.WalkDirFunc
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data string
			// WriteByteOrderMark is the writeByteOrderMark argument value.
			WriteByteOrderMark bool
		}
	}
	lockDirectoryExists           sync.RWMutex
	lockFileExists                sync.RWMutex
	lockGetAccessibleEntries      sync.RWMutex
	lockReadFile                  sync.RWMutex
	lockRealpath                  sync.RWMutex
	lockRemove                    sync.RWMutex
	lockStat                      sync.RWMutex
	lockUseCaseSensitiveFileNames sync.RWMutex
	lockWalkDir                   sync.RWMutex
	lockWriteFile                 sync.RWMutex
}

// DirectoryExists calls DirectoryExistsFunc.
func (mock *FSMock) DirectoryExists(path string) bool {
	if mock.DirectoryExistsFunc == nil {
		panic("FSMock.DirectoryExistsFunc: method is nil but FS.DirectoryExists was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockDirectoryExists.Lock()
	mock.calls.DirectoryExists = append(mock.calls.DirectoryExists, callInfo)
	mock.lockDirectoryExists.Unlock()
	return mock.DirectoryExistsFunc(path)
}

// DirectoryExistsCalls gets all the calls that were made to DirectoryExists.
// Check the length with:
//
//	len(mockedFS.DirectoryExistsCalls())
func (mock *FSMock) DirectoryExistsCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockDirectoryExists.RLock()
	calls = mock.calls.DirectoryExists
	mock.lockDirectoryExists.RUnlock()
	return calls
}

// FileExists calls FileExistsFunc.
func (mock *FSMock) FileExists(path string) bool {
	if mock.FileExistsFunc == nil {
		panic("FSMock.FileExistsFunc: method is nil but FS.FileExists was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockFileExists.Lock()
	mock.calls.FileExists = append(mock.calls.FileExists, callInfo)
	mock.lockFileExists.Unlock()
	return mock.FileExistsFunc(path)
}

// FileExistsCalls gets all the calls that were made to FileExists.
// Check the length with:
//
//	len(mockedFS.FileExistsCalls())
func (mock *FSMock) FileExistsCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockFileExists.RLock()
	calls = mock.calls.FileExists
	mock.lockFileExists.RUnlock()
	return calls
}

// GetAccessibleEntries calls GetAccessibleEntriesFunc.
func (mock *FSMock) GetAccessibleEntries(path string) vfs.Entries {
	if mock.GetAccessibleEntriesFunc == nil {
		panic("FSMock.GetAccessibleEntriesFunc: method is nil but FS.GetAccessibleEntries was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGetAccessibleEntries.Lock()
	mock.calls.GetAccessibleEntries = append(mock.calls.GetAccessibleEntries, callInfo)
	mock.lockGetAccessibleEntries.Unlock()
	return mock.GetAccessibleEntriesFunc(path)
}

// GetAccessibleEntriesCalls gets all the calls that were made to GetAccessibleEntries.
// Check the length with:
//
//	len(mockedFS.GetAccessibleEntriesCalls())
func (mock *FSMock) GetAccessibleEntriesCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGetAccessibleEntries.RLock()
	calls = mock.calls.GetAccessibleEntries
	mock.lockGetAccessibleEntries.RUnlock()
	return calls
}

// ReadFile calls ReadFileFunc.
func (mock *FSMock) ReadFile(path string) (string, bool) {
	if mock.ReadFileFunc == nil {
		panic("FSMock.ReadFileFunc: method is nil but FS.ReadFile was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockReadFile.Lock()
	mock.calls.ReadFile = append(mock.calls.ReadFile, callInfo)
	mock.lockReadFile.Unlock()
	return mock.ReadFileFunc(path)
}

// ReadFileCalls gets all the calls that were made to ReadFile.
// Check the length with:
//
//	len(mockedFS.ReadFileCalls())
func (mock *FSMock) ReadFileCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockReadFile.RLock()
	calls = mock.calls.ReadFile
	mock.lockReadFile.RUnlock()
	return calls
}

// Realpath calls RealpathFunc.
func (mock *FSMock) Realpath(path string) string {
	if mock.RealpathFunc == nil {
		panic("FSMock.RealpathFunc: method is nil but FS.Realpath was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockRealpath.Lock()
	mock.calls.Realpath = append(mock.calls.Realpath, callInfo)
	mock.lockRealpath.Unlock()
	return mock.RealpathFunc(path)
}

// RealpathCalls gets all the calls that were made to Realpath.
// Check the length with:
//
//	len(mockedFS.RealpathCalls())
func (mock *FSMock) RealpathCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockRealpath.RLock()
	calls = mock.calls.Realpath
	mock.lockRealpath.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *FSMock) Remove(path string) error {
	if mock.RemoveFunc == nil {
		panic("FSMock.RemoveFunc: method is nil but FS.Remove was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(path)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedFS.RemoveCalls())
func (mock *FSMock) RemoveCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Stat calls StatFunc.
func (mock *FSMock) Stat(path string) vfs.FileInfo {
	if mock.StatFunc == nil {
		panic("FSMock.StatFunc: method is nil but FS.Stat was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockStat.Lock()
	mock.calls.Stat = append(mock.calls.Stat, callInfo)
	mock.lockStat.Unlock()
	return mock.StatFunc(path)
}

// StatCalls gets all the calls that were made to Stat.
// Check the length with:
//
//	len(mockedFS.StatCalls())
func (mock *FSMock) StatCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockStat.RLock()
	calls = mock.calls.Stat
	mock.lockStat.RUnlock()
	return calls
}

// UseCaseSensitiveFileNames calls UseCaseSensitiveFileNamesFunc.
func (mock *FSMock) UseCaseSensitiveFileNames() bool {
	if mock.UseCaseSensitiveFileNamesFunc == nil {
		panic("FSMock.UseCaseSensitiveFileNamesFunc: method is nil but FS.UseCaseSensitiveFileNames was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUseCaseSensitiveFileNames.Lock()
	mock.calls.UseCaseSensitiveFileNames = append(mock.calls.UseCaseSensitiveFileNames, callInfo)
	mock.lockUseCaseSensitiveFileNames.Unlock()
	return mock.UseCaseSensitiveFileNamesFunc()
}

// UseCaseSensitiveFileNamesCalls gets all the calls that were made to UseCaseSensitiveFileNames.
// Check the length with:
//
//	len(mockedFS.UseCaseSensitiveFileNamesCalls())
func (mock *FSMock) UseCaseSensitiveFileNamesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUseCaseSensitiveFileNames.RLock()
	calls = mock.calls.UseCaseSensitiveFileNames
	mock.lockUseCaseSensitiveFileNames.RUnlock()
	return calls
}

// WalkDir calls WalkDirFunc.
func (mock *FSMock) WalkDir(root string, walkFn vfs.WalkDirFunc) error {
	if mock.WalkDirFunc == nil {
		panic("FSMock.WalkDirFunc: method is nil but FS.WalkDir was just called")
	}
	callInfo := struct {
		Root   string
		WalkFn vfs.WalkDirFunc
	}{
		Root:   root,
		WalkFn: walkFn,
	}
	mock.lockWalkDir.Lock()
	mock.calls.WalkDir = append(mock.calls.WalkDir, callInfo)
	mock.lockWalkDir.Unlock()
	return mock.WalkDirFunc(root, walkFn)
}

// WalkDirCalls gets all the calls that were made to WalkDir.
// Check the length with:
//
//	len(mockedFS.WalkDirCalls())
func (mock *FSMock) WalkDirCalls() []struct {
	Root   string
	WalkFn vfs.WalkDirFunc
} {
	var calls []struct {
		Root   string
		WalkFn vfs.WalkDirFunc
	}
	mock.lockWalkDir.RLock()
	calls = mock.calls.WalkDir
	mock.lockWalkDir.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *FSMock) WriteFile(path string, data string, writeByteOrderMark bool) error {
	if mock.WriteFileFunc == nil {
		panic("FSMock.WriteFileFunc: method is nil but FS.WriteFile was just called")
	}
	callInfo := struct {
		Path               string
		Data               string
		WriteByteOrderMark bool
	}{
		Path:               path,
		Data:               data,
		WriteByteOrderMark: writeByteOrderMark,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(path, data, writeByteOrderMark)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedFS.WriteFileCalls())
func (mock *FSMock) WriteFileCalls() []struct {
	Path               string
	Data               string
	WriteByteOrderMark bool
} {
	var calls []struct {
		Path               string
		Data               string
		WriteByteOrderMark bool
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
